/*
层序遍历 (Level Order Traversal) 的天选之子是 BFS (广度优先搜索)，通常使用 队列 (Queue) 来实现。

这也是面试官最希望看到的解法，因为它符合人的直觉：排队。

思路：

准备一个队列，先把 Root 放进去。

只要队列不空：

记录当前队列的长度 n（这一刻队列里全是同一层的节点）。

只处理这 n 个节点：

弹出一个，记下值。

如果有左孩子，左孩子入队。

如果有右孩子，右孩子入队。

这 n 个处理完，刚好这一层的孩子（下一层）也都排好队了。


*/

class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
		vector<vector<int>> result;
		if (root == nullptr)
			return result;
		queue<TreeNode*> p;
		p.push(root);

		while (!p.empty())
		{
			int current_point_num = p.size();
			vector<int> current_level;

			for(int i = 0; i < current_point_num; i++)
			{
				TreeNode* temp = p.front();
				p.pop();
				current_level.push_back(temp->val);

				if (temp->left) p.push(temp->left);
				if (temp->right)p.push(temp->right);

			}
			result.push_back(current_level);

		}
		return result;

    }
};


//第二次做              问题没有及时想到queue   ，vector<int> temp; 在每一个while循环后，就会更新  不用故意更新
class Solution {
public:
	vector<vector<int>> levelOrder(TreeNode* root) {
		vector<vector<int>> result;
		if (root == nullptr) return result;
		queue<TreeNode*> nodeaddr;
		nodeaddr.push(root);
		int num_size = 0;
		while (!nodeaddr.empty())
		{
			num_size = nodeaddr.size();
			vector<int> temp;
			for (int i = 0; i < num_size; i++)
			{
				TreeNode* temp_addr = nodeaddr.front();
				temp.push_back(temp_addr->val);
				nodeaddr.pop();
				if(temp_addr->left!=nullptr) nodeaddr.push(temp_addr->left);
				if(temp_addr->right != nullptr)nodeaddr.push(temp_addr->right);
			}
			result.push_back(temp);
		}
		return result;
	}
};

