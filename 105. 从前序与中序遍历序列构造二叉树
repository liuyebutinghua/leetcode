/*
这道题就像是在玩拼图游戏。
如果只给你一个视角（比如只给前序），
你拼不出原来的树，因为有很多种可能性。
但是，如果你同时拥有前序（Preorder）和中序（Inorder），你就能利用它们各自的特性，把树唯一的确定下来。
1. 核心解题逻辑：定位 + 切割我们需要利用这两种遍历最根本的性质：前序遍历 (Preorder)：[ 根节点 | 左子树所有节点 | 右子树所有节点 ]特权：
第一个元素永远是当前的 Root。中序遍历 (Inorder)：[ 左子树所有节点 | 根节点 | 右子树所有节点 ]特权：一旦知道了 Root 在哪里，Root 左边的就是左子树
，Root 右边的就是右子树。2. 手把手推演假设输入是：preorder = [3, 9, 20, 15, 7]inorder = [9, 3, 15, 20, 7]Step 1：找老大 (Find Root)看 preorder 的第一个数
：3。-> 3 就是整棵树的根节点。Step 2：划地盘 (Split)去 inorder 里找 3 在哪里？它在下标 1 的位置：[9, (3), 15, 20, 7]。这一刀切下去：左子树的中序：
[9] （3 左边的）右子树的中序：[15, 20, 7] （3 右边的）Step 3：算数量 (Calculate Size)这点最关键！我们发现左子树的中序数组只有一个元素 [9]。
说明左子树的长度是 1。Step 4：回看前序 (Back to Preorder)回到 preorder，我们跳过根节点 3。既然左子树长度是 1，那么紧接着 3 后面的 1 个数，
就是左子树的前序。左子树的前序：[9]剩下的就是右子树的前序。右子树的前序：[20, 15, 7]Step 5：递归 (Recursion)现在问题变成了两个规模更小的子问题：
构造左孩子：用 pre=[9], in=[9]构造右孩子：用 pre=[20, 15, 7], in=[15, 20, 7]3. 代码实现的难点：下标计算如果我们每次递归都去新建数组（vector 切片），
C++ 会非常慢且耗内存。最优雅的写法是：传递下标范围。我们需要维护这几个变量：pre_start, pre_end：当前子树在前序数组中的范围。in_start, in_end：
当前子树在中序数组中的范围。关键公式（建议手写一遍）：假设我们在中序里找到了根节点的位置 index。那么 左子树的长度 left_size = index - in_start。
左子树范围：前序：[pre_start + 1, pre_start + left_size]中序：[in_start, index - 1]右子树范围：前序：[pre_start + left_size + 1, pre_end]中序：
[index + 1, in_end]4. 优化：快速查找每次去 inorder 里找根节点的位置如果不优化，需要 $O(N)$ 遍历，总时间会变成 $O(N^2)$。我们可以用一个 哈希表 (unordered_map) 
提前把 inorder 的元素和下标存起来，这样查找就变成 $O(1)$ 了。

*/
class Solution {
public:
	unordered_map<int, int > inorder_map;//用来记录inorder值所对应的下标，主要是用于查找根节点所在下表

	TreeNode* my_build(vector<int>& preorder, int pre_left, int pre_right,
		vector<int>& inorder, int in_left, int in_right)
	{
		if (in_left > in_right)   return nullptr;//此时已经没有节点了

		TreeNode* newnode = new TreeNode(0);//初始化
		newnode->val = preorder[pre_left];
		int suoyin_weizhi = inorder_map[preorder[pre_left]];
		int size_shu = suoyin_weizhi - in_left;//返回的是中序遍历中的根节点下标   计算左节点的长度
		newnode->left = my_build(preorder,pre_left+1, pre_left + size_shu, inorder, in_left, suoyin_weizhi -1);
		newnode->right = my_build(preorder, pre_left + size_shu + 1, pre_right, inorder, suoyin_weizhi + 1, in_right);
		return newnode;
	}

	TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		
		for (int i = 0; i < preorder.size(); i++)
		{
			inorder_map[inorder[i]] =i ;
		}

		return my_build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);

	}
};
