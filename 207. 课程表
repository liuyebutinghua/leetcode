/*
1. 核心思路：为什么是找“环”？
想象一下选课的场景：想修 A，必须先修 B。 ($B \to A$)想修 B，必须先修 C。
($C \to B$)想修 C，必须先修 A。 ($A \to C$)这就形成了 $A \to C \to B \to A$ 的死循环
。如果你遇到了这种情况，你永远没法开始第一门课，所以不可能完成所有课程。
结论：没有环 $\rightarrow$ 可以完成（返回 true）。有环 $\rightarrow$ 卡死了（返回 false）。


这道题（LeetCode 207. 课程表）是图论中**“拓扑排序” (Topological Sort)** 的入门经典题。
别被这个名字吓到，它的核心逻辑其实非常简单，就一句话：检测这个有向图中，有没有“环” (Cycle)？
1. 核心思路：为什么是找“环”？想象一下选课的场景：想修 A，必须先修 B。 ($B \to A$)想修 B，必须先修 C。 (
$C \to B$)想修 C，必须先修 A。 ($A \to C$)这就形成了 $A \to C \to B \to A$ 的死循环。如果你遇到了这种情况，
你永远没法开始第一门课，所以不可能完成所有课程。结论：没有环 $\rightarrow$ 可以完成（返回 true）。
有环 $\rightarrow$ 卡死了（返回 false）。2. 解题武器：入度表 (Indegree) + BFS最直观的方法是使用 BFS（广度优先搜索），
这种方法也被称为 Kahn 算法。我们需要引入一个概念：入度 (Indegree)。入度：有多少个箭头指向我？（也就是：我有多少门还没修的先修课？）
算法流程（像玩消消乐一样）：统计情报：遍历所有依赖关系，算出每一门课的入度。同时建立邻接表（谁依赖我？），方便后面通知它们。
寻找突破口：一开始，哪门课可以直接修？当然是入度为 0 的课（没有先修课，或者先修课已经修完）。把所有 入度为 0 的课扔进队列
。开始修课 (BFS)：当队列不为空时，拿出一门课（比如课程 X）。修完 X 了！ 计数器 +1。通知下游：看看 X 是谁的先修课？（比如 X 是 Y 的先修课）。
解锁：既然 X 修完了，Y 的入度就减 1（Y 还要等的课少了一门）。检查：如果 Y 的入度变成 0 了，说明 Y 也能修了！把 Y 扔进队列。
最后审判：如果你修完的课程数量 count 等于总课程数 numCourses，说明全部修完了 -> true。如果 count < numCourses，
说明剩下的课依然有入度（互相依赖，形成了环），修不动了 -> false。

*/





//AI程序
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 1. 准备工作
        // 邻接表：adj[1] = {0, 2} 表示修完 1 就能去修 0 和 2
        // 注意方向：题目说 [0, 1] 表示先 1 后 0，所以是 1 -> 0
        vector<vector<int>> adj(numCourses);
        // 入度表：indegree[i] 表示课程 i 还有几门先修课没修
        vector<int> indegree(numCourses, 0);

        // 2. 建图 & 统计入度
        for (auto& p : prerequisites) {
            int cur = p[0];  // 也就是箭头指向的目标
            int pre = p[1];  // 也就是先修课
            adj[pre].push_back(cur); // pre -> cur
            indegree[cur]++;         // cur 的入度 + 1
        }

        // 3. 寻找起跑线：把所有没有门槛的课（入度为0）放入队列
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        // 4. BFS 开始消消乐
        int count = 0; // 记录我们修了多少门课
        while (!q.empty()) {
            int finishedCourse = q.front();
            q.pop();
            count++; // 成功修了一门

            // 看看这门课修完，能解锁哪些后续课程
            for (int nextCourse : adj[finishedCourse]) {
                indegree[nextCourse]--; // 后续课程的门槛降低
                
                // 如果门槛降为 0，说明可以修了
                if (indegree[nextCourse] == 0) {
                    q.push(nextCourse);
                }
            }
        }

        // 5. 结果判断：是不是修完了所有的课？
        return count == numCourses;
    }
};

//我的程序
class Solution{
public:
    bool canFinish(int numCourses, vector<vector<int>>&prerequisites) {

        vector<vector<int>> adj(numCourses);//adj[i]={0,1};   用来表示修完i  就可以去修  0 ，1
        vector<int> indegree(numCourses,0);//indegree[1]=2;//表示  1 课程需要两次解锁才能修

        for (auto& p : prerequisites)//p是一个vector<int>类型  且根据题意 为[x,y]的形式  y 是需要提前修的课程   x 是计划修的课程
        {
            int pre = p[1];
            int cur = p[0];
            adj[pre].push_back(cur);  //表示 修完pre才能修cur
            indegree[cur]++;    
        }

        queue<int> q;//表示 可以修的课程的队列

        for (int i = 0; i < numCourses; i++)
        {
            if (indegree[i] == 0)
            {
                q.push(i);//把可以修的课程加入到修的队列中
            }
        }

        int count=0;//表示已经修的课程的数量，用于最后与numCourses进行对比  
        while (!q.empty())
        {
            int course = q.front();//修的课程的序号
            q.pop();
            count++;

            for (int xiaoke: adj[course])
            {
                indegree[xiaoke]--;
                if (indegree[xiaoke] == 0) q.push(xiaoke);

            }
        }
        return count == numCourses;
    }
};


/*
易错点：
在 C++ 中，局部变量（在函数内部定义的 int）如果只声明不赋值，它的值是“垃圾值”（随机的内存残留值），而不是默认的 0。
*/
//第二次做
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> bixu(numCourses);//bixu[i]=[a,c]  表示 i修完后， 可以修a ,c  

        vector<int> rudubiao(numCourses,0); //rudubiao[0]=1表示，要想修0 ，还有一门课要提前修

        queue<int> xiukeqingdan;//当rudubiao表为0时，可以加入xiukeqingdan进行修课

      
        for (auto& p : prerequisites)
        {
            int pre = p[0];
            int cur = p[1];
            bixu[pre].push_back(cur);
            rudubiao[cur]++;
        }

        for (int i = 0; i < numCourses; i++)
        {
            if (rudubiao[i] == 0)
            {
                xiukeqingdan.push(i);
            }

        }

        int xiuke_num = 0;
        while (!xiukeqingdan.empty())
        {
            int ke = xiukeqingdan.front();
            xiukeqingdan.pop();
            xiuke_num++;

            for (auto& p : bixu[ke])
            {
                rudubiao[p]--;
                if (rudubiao[p] == 0)
                {
                    xiukeqingdan.push(p);
                }
            }

        }

        return  xiuke_num == numCourses;


    }
};



