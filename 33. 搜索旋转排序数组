/*
解题思路：
第一种：
寻找旋转点 $k$（也就是数组中最小值的索引）。根据 $k$ 还原，判断 target 是在左半段还是右半段，然后进行普通的二分查找。

第二种：
核心原理：局部有序
对于旋转排序数组（例如 [4,5,6,7,0,1,2]），无论你在哪里切一刀（mid），切出来的两半里，肯定有一半是有序的，另一半是乱序的。

情况 A：切在左半坡。例如 mid 在 6 的位置。

[4, 5, 6] (有序) 和 [7, 0, 1, 2] (乱序)。

判断依据：nums[left] <= nums[mid]。

情况 B：切在右半坡。例如 mid 在 1 的位置。

[4, 5, 6, 7, 0] (乱序) 和 [1, 2] (有序)。

判断依据：nums[left] > nums[mid]。

利用这个特性，我们可以只写一个 while 循环解决战斗。

*/
//第一种思路的代码：
class Solution {
public:
    // 步骤1：找旋转点（最小值的索引）
    int findMinIndex(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }

    // 步骤2：标准的二分查找
    int binarySearch(vector<int>& nums, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }

    int search(vector<int>& nums, int target) {
        if (nums.empty()) return -1;
        
        // 1. 先找到旋转点 k
        int k = findMinIndex(nums);

        // 2. 根据 target 和 nums[0] 的关系，决定去哪一段查
        // 如果 target 比第一个元素大（或者相等），说明它肯定在左半段 [0, k-1]
        // 除非 k=0，那就说明整个数组没旋转
        if (k == 0) {
            return binarySearch(nums, target, 0, nums.size() - 1);
        }
        
        if (target >= nums[0]) {
            return binarySearch(nums, target, 0, k - 1);
        } else {
            // 否则，它在右半段 [k, n-1]
            return binarySearch(nums, target, k, nums.size() - 1);
        }
    }
};



//第二种思路的代码：


//AI的代码
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // 1. 找到目标，直接返回
            if (nums[mid] == target) {
                return mid;
            }

            // 2. 核心判断：哪一半是有序的？
            
            // 如果左边是有序的 (比如 [4,5,6,7,0,1,2], mid=3(7), left=0(4))
            // 注意：这里要有等号，处理 left == mid 的情况
            if (nums[left] <= nums[mid]) {
                // 既然左边有序，那我们就看看 target 在不在左边这个“正常”的范围内
                // 必须满足 nums[left] <= target < nums[mid]
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1; // 目标在左边，缩右界
                } else {
                    left = mid + 1;  // 目标不在左边，去乱序的右边找
                }
            }
            // 否则，右边肯定是有序的 (比如 [6,7,0,1,2,4,5], mid=3(1), left=0(6))
            else {
                // 既然右边有序，那我们就看看 target 在不在右边这个“正常”的范围内
                // 必须满足 nums[mid] < target <= nums[right]
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;  // 目标在右边，缩左界
                } else {
                    right = mid - 1; // 目标不在右边，去乱序的左边找
                }
            }
        }

        return -1;
    }
};


//我的代码
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while(left<=right)
        {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target)
            {
                return mid;
            }

            if(nums[mid]>=nums[left])//左边有序
            {
                if (target >= nums[left] && target < nums[mid])
                {
                    right = mid - 1;
                }
                else 
                {
                    left = mid + 1;
                }
            
            }
            else//右边有序
            {
                if (target <= nums[right] && target > nums[mid])
                {
                    left = mid + 1;
                }
                else 
                {
                    right = mid - 1;
                }

            }

        }
        return -1;
    }
    
};

//第二次做
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;


        while (left<= right)
        {
            int mid = left + (right-left)/2;

            if (nums[mid] == target)
            {
                return mid;
            }
            else if (nums[mid] >= nums[left])//左边有序          易错点：区间判断错误   且忽略nums[mid] >= nums[left]   的=号  忽略了mid=left的条件
            {
                if (nums[mid] > target&& target>=nums[left])
                {
                    right = mid - 1;
                }
                else
                {
                    left = mid + 1;
                }


            }
            else//右边有序
            {
                if (nums[mid] < target && target <= nums[right])
                {
                    left = mid + 1;
                }
                else
                {
                    right = mid - 1;
                }
            }

        }


        return -1;
    }

};





