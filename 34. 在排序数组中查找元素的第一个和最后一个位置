/*
解题思路：
正确解题思路：两次二分查找既然时间复杂度限制在 $O(\log n)$，
我们不能用线性扫描（不能找到一个然后向左右两边挨个找，那样最坏是 $O(n)$）。
我们需要写两个二分查找：找左边界 (Left Bound)：找到 target 第一次出现的位置。
找右边界 (Right Bound)：找到 target 最后一次出现的位置。


核心技巧：当 nums[mid] == target 时，别停下来！
找左边界时：记录下当前位置，然后收缩右边界 (right = mid - 1)，
看看左边还有没有 target。找右边界时：记录下当前位置，
然后收缩左边界 (left = mid + 1)，看看右边还有没有 target。


*/
//AI的代码：
class Solution {
public:
    // 辅助函数：只负责找边界
    // isLeft = true 表示找左边界，false 表示找右边界
    int searchBound(vector<int>& nums, int target, bool isLeft) {
        int left = 0;
        int right = nums.size() - 1;
        int bound = -1; // 初始化为 -1，表示没找到

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                bound = mid; // 1. 先记录当前位置（可能是答案）
                
                // 2. 关键点：决定往哪边继续搜
                if (isLeft) {
                    right = mid - 1; // 想找左边界，就往左边逼近
                } else {
                    left = mid + 1;  // 想找右边界，就往右边逼近
                }
            } 
            else if (nums[mid] < target) {
                left = mid + 1;
            } 
            else {
                right = mid - 1;
            }
        }
        return bound;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        // 1. 找左边界
        int leftIdx = searchBound(nums, target, true);
        
        // 如果左边界都没找到，说明数组里根本没有 target，直接返回 [-1, -1]
        if (leftIdx == -1) {
            return {-1, -1};
        }

        // 2. 找右边界
        int rightIdx = searchBound(nums, target, false);

        return {leftIdx, rightIdx};
    }
};



//我的代码
class Solution {
public:

    int searchside(vector<int>& nums, int& target,int left,int right,bool isleft)//isleft   true 表示现在是不是在寻找左边界，false 表示在寻找右边界
    {
        int temp = -1;//用于存储边界值， 初始值赋值为-1
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target)
            {
                temp = mid;
                if (isleft == true)
                {
                    right=mid-1;
                }
                else
                {
                    left = mid + 1;
                }

            }
            else if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }

        return temp;
    }


    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1;

        if (right < left) 
            return { -1,-1 };


        int leftIndex = searchside(nums, target, left, right,true);
        if(leftIndex==-1) return { -1,-1 };

        int rightIndex = searchside(nums, target, leftIndex, right, false);

        return { leftIndex,rightIndex };
    }
};




