/*
二分查找通常推荐用 循环 (Iterative) 写法，更不容易出错，且空间复杂度为 $O(1)$。


*/






//AI的代码
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 注意：这里是闭区间 [0, n-1]

        while (left <= right) { // 注意：要有 = 号，处理边界情况
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid; // 找到了，直接返回索引
            } else if (nums[mid] < target) {
                left = mid + 1; // 目标在右边，left 移到 mid 右侧
            } else {
                right = mid - 1; // 目标在左边，right 移到 mid 左侧
            }
        }
        
        // 【核心结论】
        // 当循环结束时，left 就是目标值应该插入的位置
        // 无论 target 是找到了，还是没找到，left 总是指向“第一个 >= target”的位置
        return left;
    }
};



//我的代码

class Solution {
public:
    int result;

    void backtracking(vector<int>& nums, int& target,int left ,int right)
    {
        if (left > right) {
            result = left;
            return;
        }
        int mid = left + (right - left) / 2;
        if (nums[mid] > target)
        {
            backtracking(nums, target, left, mid-1);
        }
        else if (nums[mid] < target)
        {
            backtracking(nums, target, mid+1, right);
        }
        else
        {
            result = mid;
            return;
        }


    }

    int searchInsert(vector<int>& nums, int target) {
        result = 0;
        backtracking(nums, target,0, nums.size()-1);
        return result;
    }
};
