/*
二分查找通常推荐用 循环 (Iterative) 写法，更不容易出错，且空间复杂度为 $O(1)$。


*/






//AI的代码
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 注意：这里是闭区间 [0, n-1]

        while (left <= right) { // 注意：要有 = 号，处理边界情况
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid; // 找到了，直接返回索引
            } else if (nums[mid] < target) {
                left = mid + 1; // 目标在右边，left 移到 mid 右侧
            } else {
                right = mid - 1; // 目标在左边，right 移到 mid 左侧
            }
        }
        
        // 【核心结论】
        // 当循环结束时，left 就是目标值应该插入的位置
        // 无论 target 是找到了，还是没找到，left 总是指向“第一个 >= target”的位置
        return left;
    }
};



//我的代码

class Solution {
public:
    int result;

    void backtracking(vector<int>& nums, int& target,int left ,int right)
    {
        if (left > right) {
            result = left;
            return;
        }
        int mid = left + (right - left) / 2;
        if (nums[mid] > target)
        {
            backtracking(nums, target, left, mid-1);
        }
        else if (nums[mid] < target)
        {
            backtracking(nums, target, mid+1, right);
        }
        else
        {
            result = mid;
            return;
        }


    }

    int searchInsert(vector<int>& nums, int target) {
        result = 0;
        backtracking(nums, target,0, nums.size()-1);
        return result;
    }
};

//我的第二次代码
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left<=right)
        {
            int mid = left + (right - left) / 2;

            if (nums[mid] < target)
            {
                left = mid+1;
            }
            else if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else
            {
                return mid;
            }
        }

        return left;

    }
};


/*
1. 知识点：
while (left < right)  和  while (left <= right)的使用条件
  
如果你写 right = nums.size() - 1，说明你依然认为 right 是有效位置，那么循环必须用 <=，且更新时要用 mid - 1。

如果你写 right = nums.size()，说明 right 是无效的越界位置，那么循环用 <，且更新时用 right = mid。

2. 模拟演示（一图胜千言）
假设数组为 nums = [1, 3, 5]，我们要找插入位置 target = 2。 正确答案应该是索引 1（插在 1 和 3 之间）。

情况 A：使用 while (left <= right) （你的正确写法）
第一轮：

left = 0, right = 2, mid = 1。

nums[1] 是 3。

3 > 2，所以 right = mid - 1 = 0。

第二轮：

此时 left = 0, right = 0。（注意：此时两者相等）

满足 0 <= 0，进入循环。

mid = 0。

nums[0] 是 1。

1 < 2，所以 left = mid + 1 = 1。

结束：

此时 left = 1, right = 0。

1 <= 0 不成立，退出循环。

返回 left (即 1)。答案正确！

情况 B：使用 while (left < right) （去掉等于号）
第一轮：

同上，left = 0, right = 2, mid = 1。

right 更新为 0。

第二轮判断：

此时 left = 0, right = 0。

0 < 0 不成立！循环直接终止！

程序没有检查索引 0 处的元素（也就是数字 1）。

结束：

直接返回 left (即 0)。

答案错误！ 程序告诉你把 2 插在 1 的前面（索引0），但这显然不对。
*/
