/*
为了解决上面的问题，我们通常采用**“主函数 + 辅助函数”**的模式。

主函数：负责创建 vector，调用递归，最后返回结果。

辅助函数：负责干活（递归），返回值是 void，专门往引用传进来的 vector 里填数。

*/
class Solution {
public:

	void  my_traversal(TreeNode* root, vector<int>& result)
	{
		if (root == nullptr)
		{
			return;
		}

		my_traversal(root->left, result);

		result.push_back(root->val);

		my_traversal(root->right, result);

	}


	vector<int> inorderTraversal(TreeNode* root) {

		vector<int> result;// 在函数内部定义，保证每次都是新的
		my_traversal(root, result);
		return result;
	}
};
