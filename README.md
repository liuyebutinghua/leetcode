# leetcode
这个数据库中记录的是我使用C练习LEETCODE上面的解题代码
# 算法思维训练指南

## 1. 理解题目的方法论

### 第一步：慢读题目
- **逐字逐句分析**，不要急着写代码
- **用自己的话重述**题目要求
- **找出关键词**：输入格式、输出要求、约束条件
- **画图理解**：用具体例子画出过程

### 第二步：分析示例
```
例如合并链表题目：
输入：list1 = [1,2,4], list2 = [1,3,4]
输出：[1,1,2,3,4,4]

思考过程：
1. 两个链表都是升序的
2. 需要保持升序合并
3. 每次选择较小的元素
4. 直到一个链表为空，剩下的直接连接
```

## 2. 思路整理的5W1H方法

### What - 要做什么？
- 明确核心任务
- 确定输入输出格式

### Why - 为什么这样做？
- 理解算法背后的逻辑
- 为什么选择这种方法

### Where - 在哪里操作？
- 确定操作的数据结构
- 明确操作的位置

### When - 什么时候做？
- 确定循环/递归的条件
- 明确终止条件

### Who - 谁来执行？
- 确定需要的变量/指针
- 分配各自的职责

### How - 怎么实现？
- 具体的实现步骤
- 边界情况处理

## 3. 代码组织的"三段式"结构

### 第一段：初始化
```c
// 1. 声明所需变量
// 2. 处理特殊情况（空指针、边界条件）
// 3. 设置初始状态

struct ListNode dummy;
dummy.next = NULL;
struct ListNode* current = &dummy;

// 处理边界情况
if (list1 == NULL) return list2;
if (list2 == NULL) return list1;
```

### 第二段：核心逻辑
```c
// 主要的循环或递归逻辑
// 保持条件清晰，逻辑简单

while (list1 != NULL && list2 != NULL) {
    if (list1->val <= list2->val) {
        current->next = list1;
        list1 = list1->next;
    } else {
        current->next = list2;
        list2 = list2->next;
    }
    current = current->next;
}
```

### 第三段：收尾工作
```c
// 处理剩余情况
// 返回结果

if (list1 != NULL) {
    current->next = list1;
} else {
    current->next = list2;
}

return dummy.next;
```

## 4. 变量命名和注释策略

### 有意义的变量名
```c
// ❌ 不好的命名
struct ListNode* p, *q, *r;

// ✅ 好的命名
struct ListNode* current;
struct ListNode* list1_ptr;
struct ListNode* next_node;
```

### 注释要说明"为什么"
```c
// ❌ 描述代码在做什么
// 将p指向下一个节点
p = p->next;

// ✅ 说明为什么这样做
// 移动到下一个节点，继续比较
current = current->next;
```

## 5. 调试思维

### 手动追踪
```
示例：合并 [1,2,4] 和 [1,3,4]

初始状态：
current -> dummy -> NULL
list1 -> 1 -> 2 -> 4
list2 -> 1 -> 3 -> 4

第1步：比较1和1，选择list1的1
current -> dummy -> 1 -> NULL
list1 -> 2 -> 4
list2 -> 1 -> 3 -> 4

第2步：比较2和1，选择list2的1
current -> dummy -> 1 -> 1 -> NULL
list1 -> 2 -> 4  
list2 -> 3 -> 4

...继续追踪
```

### 关键点检查
- **循环不变量**：每次循环后什么条件保持成立？
- **边界条件**：空链表、单元素链表怎么处理？
- **指针安全**：是否有空指针解引用的风险？

## 6. 常见思维模式

### 双指针技巧
```c
// 快慢指针、左右指针、滑动窗口
struct ListNode* slow = head;
struct ListNode* fast = head;
```

### 虚拟头节点
```c
// 简化链表操作，避免特殊情况处理
struct ListNode dummy;
dummy.next = head;
```

### 分治思想
```c
// 将大问题分解为小问题
if (问题规模小) {
    直接解决;
} else {
    分解为子问题;
    递归解决子问题;
    合并结果;
}
```

## 7. 练习建议

### 循序渐进
1. **先理解再实现**：确保完全理解题意
2. **先简单再复杂**：从基础版本开始
3. **先正确再优化**：功能正确后考虑性能

### 反思总结
- 每道题后写总结：用到了什么技巧？
- 对比不同解法：时间空间复杂度如何？
- 记录常见模式：积累解题套路

### 代码审查
```c
// 自问自答：
// 1. 这段代码在做什么？
// 2. 为什么要这样做？
// 3. 有没有更简单的方式？
// 4. 边界情况考虑全了吗？
// 5. 变量名是否清晰？
```

## 8. 心态建议

- **慢即是快**：前期多思考，后期少调试
- **小步快跑**：每次只解决一个问题
- **拥抱错误**：每个错误都是学习机会
- **持续改进**：不断重构和优化代码

记住：**清晰的思路比复杂的技巧更重要，可读的代码比聪明的代码更有价值。**
